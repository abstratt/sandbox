/*
 * generated by Xtext 2.20.0
 */
package simpleui.ui.contentassist

import com.google.inject.Inject
import java.util.HashSet
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import simpleui.Component
import simpleui.validation.DataFactory
import value.DictionaryValue
import value.ListValue
import value.Slot
import simpleui.validation.JsonGenerator
import org.eclipse.emf.ecore.util.EcoreUtil
import value.MetadataHolder

class SimpleUILanguageProposalProvider extends AbstractSimpleUILanguageProposalProvider {

    @Inject
    private JsonGenerator jsonGenerator

    @Inject
    private DataFactory valueFactory

    override completeSlot_Name(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        // we know the type backing the dictionary
        var target = model
        var EClass objectClass
        var Iterable<EStructuralFeature> inUse = #[]
        switch target {
            Slot: {
                objectClass = target.slotFeature?.EType as EClass
            }
            DictionaryValue: {
                objectClass = target.objectClass
                inUse = target.slots.filter[slotFeature != null].map[slotFeature]
            }
            MetadataHolder: {
                objectClass = target.metadataType as EClass
            }
            ListValue: {
                objectClass = (target.eContainer as Slot).slotFeature?.EType as EClass
            }
            default:
                println("Could not match " + target)
        }
        if (objectClass == null)
            return
        val available = new HashSet(objectClass.EAllStructuralFeatures.filter [
            it.getEAnnotation("simpleui/internal") == null
        ].toSet)
        available.removeAll(inUse)
        available.forEach [ feature |
            val featureName = feature.name
            acceptor.accept(
                createCompletionProposal('''«featureName»''', '''«featureName» «if (feature.required && feature.defaultValue == null) '(required)' else ''»''',
                    null, context))
        ]

    }

    override completeSlot_Value(EObject model, Assignment assignment, ContentAssistContext context,
        ICompletionProposalAcceptor acceptor) {
        val asSlot = model as Slot
        val feature = asSlot.slotFeature
        if (feature != null) { 
            val defaultValue = jsonGenerator.generateValue(valueFactory.generateDefaultJSONValue(feature, feature.many))
            if (defaultValue != null) {
                acceptor.accept(
                    createCompletionProposal('''«defaultValue»''', '''«defaultValue»''',
                        null, context))
                return
            }
        }
        super.completeSlot_Value(model, assignment, context, acceptor) 
    }

}
